// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use crate::common_generated::*;
use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod reputation {

  use crate::common_generated::*;
  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};
#[allow(unused_imports, dead_code)]
pub mod fbs {

  use crate::common_generated::*;
  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

// struct Tag, aligned to 8
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Tag(pub [u8; 224]);
impl Default for Tag { 
  fn default() -> Self { 
    Self([0; 224])
  }
}
impl core::fmt::Debug for Tag {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    f.debug_struct("Tag")
      .field("commitment", &self.commitment())
      .field("expiration", &self.expiration())
      .field("score", &self.score())
      .field("enc_sender_id", &self.enc_sender_id())
      .field("q_big", &self.q_big())
      .field("g_prime", &self.g_prime())
      .field("x_big", &self.x_big())
      .field("signature", &self.signature())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Tag {}
impl<'a> flatbuffers::Follow<'a> for Tag {
  type Inner = &'a Tag;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Tag>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Tag {
  type Inner = &'a Tag;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Tag>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Tag {
    type Output = Tag;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(self as *const Tag as *const u8, Self::size());
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for Tag {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}

impl<'a> Tag {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    commitment: &FixedBuffer32,
    expiration: i64,
    score: i32,
    enc_sender_id: &FixedBuffer16,
    q_big: &FixedBuffer32,
    g_prime: &FixedBuffer32,
    x_big: &FixedBuffer32,
    signature: &FixedBuffer64,
  ) -> Self {
    let mut s = Self([0; 224]);
    s.set_commitment(commitment);
    s.set_expiration(expiration);
    s.set_score(score);
    s.set_enc_sender_id(enc_sender_id);
    s.set_q_big(q_big);
    s.set_g_prime(g_prime);
    s.set_x_big(x_big);
    s.set_signature(signature);
    s
  }

  pub fn commitment(&self) -> &FixedBuffer32 {
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid struct in this slot
    unsafe { &*(self.0[0..].as_ptr() as *const FixedBuffer32) }
  }

  #[allow(clippy::identity_op)]
  pub fn set_commitment(&mut self, x: &FixedBuffer32) {
    self.0[0..0 + 32].copy_from_slice(&x.0)
  }

  pub fn expiration(&self) -> i64 {
    let mut mem = core::mem::MaybeUninit::<<i64 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[32..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<i64 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_expiration(&mut self, x: i64) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[32..].as_mut_ptr(),
        core::mem::size_of::<<i64 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn score(&self) -> i32 {
    let mut mem = core::mem::MaybeUninit::<<i32 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[40..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<i32 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_score(&mut self, x: i32) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[40..].as_mut_ptr(),
        core::mem::size_of::<<i32 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn enc_sender_id(&self) -> &FixedBuffer16 {
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid struct in this slot
    unsafe { &*(self.0[44..].as_ptr() as *const FixedBuffer16) }
  }

  #[allow(clippy::identity_op)]
  pub fn set_enc_sender_id(&mut self, x: &FixedBuffer16) {
    self.0[44..44 + 16].copy_from_slice(&x.0)
  }

  pub fn q_big(&self) -> &FixedBuffer32 {
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid struct in this slot
    unsafe { &*(self.0[60..].as_ptr() as *const FixedBuffer32) }
  }

  #[allow(clippy::identity_op)]
  pub fn set_q_big(&mut self, x: &FixedBuffer32) {
    self.0[60..60 + 32].copy_from_slice(&x.0)
  }

  pub fn g_prime(&self) -> &FixedBuffer32 {
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid struct in this slot
    unsafe { &*(self.0[92..].as_ptr() as *const FixedBuffer32) }
  }

  #[allow(clippy::identity_op)]
  pub fn set_g_prime(&mut self, x: &FixedBuffer32) {
    self.0[92..92 + 32].copy_from_slice(&x.0)
  }

  pub fn x_big(&self) -> &FixedBuffer32 {
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid struct in this slot
    unsafe { &*(self.0[124..].as_ptr() as *const FixedBuffer32) }
  }

  #[allow(clippy::identity_op)]
  pub fn set_x_big(&mut self, x: &FixedBuffer32) {
    self.0[124..124 + 32].copy_from_slice(&x.0)
  }

  pub fn signature(&self) -> &FixedBuffer64 {
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid struct in this slot
    unsafe { &*(self.0[156..].as_ptr() as *const FixedBuffer64) }
  }

  #[allow(clippy::identity_op)]
  pub fn set_signature(&mut self, x: &FixedBuffer64) {
    self.0[156..156 + 64].copy_from_slice(&x.0)
  }

}

pub enum FullTagOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct FullTag<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FullTag<'a> {
  type Inner = FullTag<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> FullTag<'a> {
  pub const VT_TAG: flatbuffers::VOffsetT = 4;
  pub const VT_RANDOMNESS: flatbuffers::VOffsetT = 6;
  pub const VT_PROOF_S: flatbuffers::VOffsetT = 8;
  pub const VT_PROOF_C: flatbuffers::VOffsetT = 10;
  pub const VT_R_BIG: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    FullTag { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args FullTagArgs<'args>
  ) -> flatbuffers::WIPOffset<FullTag<'bldr>> {
    let mut builder = FullTagBuilder::new(_fbb);
    if let Some(x) = args.r_big { builder.add_r_big(x); }
    if let Some(x) = args.proof_c { builder.add_proof_c(x); }
    if let Some(x) = args.proof_s { builder.add_proof_s(x); }
    if let Some(x) = args.randomness { builder.add_randomness(x); }
    if let Some(x) = args.tag { builder.add_tag(x); }
    builder.finish()
  }


  #[inline]
  pub fn tag(&self) -> &'a Tag {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Tag>(FullTag::VT_TAG, None).unwrap()}
  }
  #[inline]
  pub fn randomness(&self) -> &'a FixedBuffer32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<FixedBuffer32>(FullTag::VT_RANDOMNESS, None).unwrap()}
  }
  #[inline]
  pub fn proof_s(&self) -> &'a FixedBuffer32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<FixedBuffer32>(FullTag::VT_PROOF_S, None).unwrap()}
  }
  #[inline]
  pub fn proof_c(&self) -> &'a FixedBuffer32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<FixedBuffer32>(FullTag::VT_PROOF_C, None).unwrap()}
  }
  #[inline]
  pub fn r_big(&self) -> &'a FixedBuffer32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<FixedBuffer32>(FullTag::VT_R_BIG, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for FullTag<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<Tag>("tag", Self::VT_TAG, true)?
     .visit_field::<FixedBuffer32>("randomness", Self::VT_RANDOMNESS, true)?
     .visit_field::<FixedBuffer32>("proof_s", Self::VT_PROOF_S, true)?
     .visit_field::<FixedBuffer32>("proof_c", Self::VT_PROOF_C, true)?
     .visit_field::<FixedBuffer32>("r_big", Self::VT_R_BIG, true)?
     .finish();
    Ok(())
  }
}
pub struct FullTagArgs<'a> {
    pub tag: Option<&'a Tag>,
    pub randomness: Option<&'a FixedBuffer32>,
    pub proof_s: Option<&'a FixedBuffer32>,
    pub proof_c: Option<&'a FixedBuffer32>,
    pub r_big: Option<&'a FixedBuffer32>,
}
impl<'a> Default for FullTagArgs<'a> {
  #[inline]
  fn default() -> Self {
    FullTagArgs {
      tag: None, // required field
      randomness: None, // required field
      proof_s: None, // required field
      proof_c: None, // required field
      r_big: None, // required field
    }
  }
}

pub struct FullTagBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FullTagBuilder<'a, 'b> {
  #[inline]
  pub fn add_tag(&mut self, tag: &Tag) {
    self.fbb_.push_slot_always::<&Tag>(FullTag::VT_TAG, tag);
  }
  #[inline]
  pub fn add_randomness(&mut self, randomness: &FixedBuffer32) {
    self.fbb_.push_slot_always::<&FixedBuffer32>(FullTag::VT_RANDOMNESS, randomness);
  }
  #[inline]
  pub fn add_proof_s(&mut self, proof_s: &FixedBuffer32) {
    self.fbb_.push_slot_always::<&FixedBuffer32>(FullTag::VT_PROOF_S, proof_s);
  }
  #[inline]
  pub fn add_proof_c(&mut self, proof_c: &FixedBuffer32) {
    self.fbb_.push_slot_always::<&FixedBuffer32>(FullTag::VT_PROOF_C, proof_c);
  }
  #[inline]
  pub fn add_r_big(&mut self, r_big: &FixedBuffer32) {
    self.fbb_.push_slot_always::<&FixedBuffer32>(FullTag::VT_R_BIG, r_big);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FullTagBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FullTagBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FullTag<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, FullTag::VT_TAG,"tag");
    self.fbb_.required(o, FullTag::VT_RANDOMNESS,"randomness");
    self.fbb_.required(o, FullTag::VT_PROOF_S,"proof_s");
    self.fbb_.required(o, FullTag::VT_PROOF_C,"proof_c");
    self.fbb_.required(o, FullTag::VT_R_BIG,"r_big");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for FullTag<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("FullTag");
      ds.field("tag", &self.tag());
      ds.field("randomness", &self.randomness());
      ds.field("proof_s", &self.proof_s());
      ds.field("proof_c", &self.proof_c());
      ds.field("r_big", &self.r_big());
      ds.finish()
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `FullTag`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_full_tag_unchecked`.
pub fn root_as_full_tag(buf: &[u8]) -> Result<FullTag, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<FullTag>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `FullTag` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_full_tag_unchecked`.
pub fn size_prefixed_root_as_full_tag(buf: &[u8]) -> Result<FullTag, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<FullTag>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `FullTag` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_full_tag_unchecked`.
pub fn root_as_full_tag_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<FullTag<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<FullTag<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `FullTag` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_full_tag_unchecked`.
pub fn size_prefixed_root_as_full_tag_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<FullTag<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<FullTag<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a FullTag and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `FullTag`.
pub unsafe fn root_as_full_tag_unchecked(buf: &[u8]) -> FullTag {
  flatbuffers::root_unchecked::<FullTag>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed FullTag and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `FullTag`.
pub unsafe fn size_prefixed_root_as_full_tag_unchecked(buf: &[u8]) -> FullTag {
  flatbuffers::size_prefixed_root_unchecked::<FullTag>(buf)
}
#[inline]
pub fn finish_full_tag_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<FullTag<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_full_tag_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<FullTag<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod fbs
}  // pub mod reputation

